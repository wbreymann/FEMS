% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/YieldCurve.R
\name{show,YieldCurve-method}
\alias{show,YieldCurve-method}
\title{#########################################################################################
#' Computes the forward rate from time t1 to time t2.
#' 
#' Q bwlf:
#' Is this a helper method or do we need a help text?
#' A auth:
#' This function still needs documentation, yes.
#' 
#' @export
setGeneric(name = "getRateAt",
           def = function(object, from, to){
             standardGeneric("getRateAt")
           })
#########################################################################################
#' @export
setMethod(f = "getRateAt",
          signature = c("YieldCurve", "character", "character"),
          definition = function(object, from, to){
            
            if (as.Date(from)<object$ReferenceDate || as.Date(to)<object$ReferenceDate) {
              stop("ErrorIn::YieldCurve::getRateAt:: No Yields can be calculated before ReferenceDate of the YieldCurve!!!")
            }
            
            # set the interpolator with year fractions and rates
            t1 <- yearFraction(object$ReferenceDate, from, object$DayCountConvention)
            t2 <- yearFraction(object$ReferenceDate, to, object$DayCountConvention)
            
            interpolator <- Interpolator(xValues = yearFraction(object$ReferenceDate, 
                                                                object$TenorDates, 
                                                                object$DayCountConvention), 
                                         yValues = object$Rates)
            
            # get rates from interpolation
            s1 <- interpolator$getValueAt(t1)
            s2 <- interpolator$getValueAt(t2)
            
            # calculate forward rate
            f12 <- (t2*s2 - t1*s1)/(t2 - t1)
            f12[is.na(f12)] <- 0
            return(f12)
          })
#' @export
setGeneric(name = "setTimeSeries",
           def = function(object, startdate, enddate, ...){
             standardGeneric("setTimeSeries")
           })
#' @export
setMethod(f = "setTimeSeries",
          signature = c("YieldCurve", "character", "character"),
          definition = function(
            object, startdate, enddate, frequency = "month", forward = "1M", ...){
            object$Data <- getRateSeries(object, startdate, enddate, 
                                               frequency = frequency, forward = forward)
          })
##############################################################
#' Generic method to retrieve the rate(s) for a specific
#' tenor(s) from a \code{\link{YieldCurve}} object
#'
#' A yield curve is a time-structure of yields, i.e. for
#' different future points in time (tenors) a yield is 
#' extracted from observed instrument prices. The 
#' \code{\link{YieldCurve}} object contains these tenors with
#' associated yields and allows to retrieve yields for any
#' tenor by inter-/extrapolation.
#' 
#' @param object An object of class \code{YieldCurve} for 
#'        which to return the yield for a given tenor
#'        
#' @param termEnd The tenor for which to return its yield. 
#'        Can be a single value or a vector of tenors.
#' 
#' @param termStart (optional) For the forward rate at t0 
#'        between times t1 and t2, termEnd refers to t2 and
#'        termStart to t1. Is a single value. If combined 
#'        with a vector for termEnd, then termStart remains
#'        the same for all t2 defined in termEnd.
#' 
#' @param ... Additional parameters:
#' \itemize{
#'  \item{"isDateEnd"}{logical indicating whether termEnd is 
#'        of date (TRUE) or term (FALSE) format. Date format is
#'        'YYYY-MM-DDTXX' with 'XX'=00 for beginning of day, or
#'        24 for end of day, and term format is 'IP' with 'I' 
#'        an integer and 'P' indicating the period (D=days, 
#'        W=weeks, M=months, Q=quarters, H=halfyears, Y=years).
#'        Default is isDateEnd=FALSE.}
#' }
#'
#' @return numeric The yield for the defined tenor
#' 
#' @seealso \code{\link{discountFactors}}
#' 
#' @examples
#' yc <- YieldCurve()
#' tenors <- c("1W", "1M", "6M", "1Y", "2Y", "5Y")
#' rates <- c(0.001, 0.0015, 0.002, 0.01, 0.02, 0.03)
#' set(yc, what = list(MarketObjectCode = "YC_Prim",
#'   Nodes = list(ReferenceDate = "2015-01-01T00", Tenors = tenors, Rates = rates)))
#' 
#' rates(yc, "1Y")  # 1-year spot rate
#' rates(yc, "2016-01-01T00", isDateEnd=TRUE) # again, 1-year spot rate
#' rates(yc, "1Y", "2015-07-01T00")  # 1-year forward rate at 2015-07-01T00
#'
## @include
#' @export
#' @docType methods
#' @rdname rts-methods
#' @aliases rates, YieldCurve, charachter, missing-method
#' @aliases rates, YieldCurve, character, character-method
setGeneric(name = "rates",
           def = function(object, termEnd, termStart, ...){
             standardGeneric("rates")
           })}
\usage{
\S4method{show}{YieldCurve}(object)
}
\description{
## @include
#' @export
#' @rdname rts-methods
#' @aliases rates, YieldCurve, character, missing-method
setMethod(f = "rates",
          signature = c("YieldCurve", "character", "missing"),
          definition = function(object, termEnd, termStart, isDateEnd = FALSE, ...){
            if (!isDateEnd) {
              # endDate <- computeTenorDates(object$ReferenceDate, termEnd)
              endDate <- shiftDates(object$ReferenceDate, termEnd)
            } else {
              endDate <- termEnd
            }
            test.dates(endDate)
            out <- getRateAt(object, object$ReferenceDate, endDate)
            return(out)
            
          })
}
\details{

}
